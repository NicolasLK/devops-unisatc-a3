# .github/workflows/docker-build.yml
# Workflow para build e push de imagem Docker para Google Container Registry
# Projeto: DevOps UNISATC A3 - Strapi Application

name: ğŸ³ Docker Build & Push

on:
  push:
    branches: [ master, main ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ master, main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      force_rebuild:
        description: 'Force rebuild even if no changes'
        type: boolean
        default: false

# VariÃ¡veis de ambiente para todo o workflow
env:
  GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GCP_PROJECT_NUMBER: 159248096205
  GCP_REGION: southamerica-east1
  GCR_HOSTNAME: gcr.io
  IMAGE_NAME: devops-unisatc-a3-strapi
  DOCKERFILE_PATH: ./Dockerfile
  # Credenciais para o Workload Identity Federation
  GCP_SERVICE_ACCOUNT: strapi-deployer@sound-dialect-458215-j9.iam.gserviceaccount.com
  WIF_POOL: github-pool-a3
  WIF_PROVIDER: github-provider

# Job para configurar variÃ¡veis de ambiente
jobs:
  setup:
    name: ğŸ”§ Setup Environment
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.meta.outputs.image-tag }}
      image-full: ${{ steps.meta.outputs.image-full }}
      should-build: ${{ steps.changes.outputs.should-build }}
      environment: ${{ steps.meta.outputs.environment }}
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ğŸ·ï¸ Generate metadata
        id: meta
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]] || [[ "${{ github.ref }}" == "refs/heads/master" ]]; then
            ENVIRONMENT="production"
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            ENVIRONMENT="production"
          else
            ENVIRONMENT="staging"
          fi
          
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            IMAGE_TAG=${GITHUB_REF#refs/tags/}
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]] || [[ "${{ github.ref }}" == "refs/heads/master" ]]; then
            IMAGE_TAG="latest"
          else
            IMAGE_TAG="${GITHUB_SHA::8}"
          fi
          
          if [[ "$ENVIRONMENT" != "production" ]]; then
            IMAGE_TAG="${IMAGE_TAG}-${ENVIRONMENT}"
          fi
          
          IMAGE_FULL="${{ env.GCR_HOSTNAME }}/${{ env.GCP_PROJECT_ID }}/${{ env.IMAGE_NAME }}:${IMAGE_TAG}"
          
          echo "image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "image-full=${IMAGE_FULL}" >> $GITHUB_OUTPUT
          echo "environment=${ENVIRONMENT}" >> $GITHUB_OUTPUT

      - name: ğŸ” Check for changes
        id: changes
        run: |
          SHOULD_BUILD="true"
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]] && [[ "${{ github.event.inputs.force_rebuild }}" == "false" ]]; then
            if git diff --quiet HEAD~1 HEAD -- . ':!.github' ':!docs' ':!*.md'; then
              SHOULD_BUILD="false"
            fi
          fi
          echo "should-build=${SHOULD_BUILD}" >> $GITHUB_OUTPUT

  # Job para build e teste da imagem
  build:
    name: ğŸ—ï¸ Build, Test & Scan Image
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.should-build == 'true'

    permissions:
      contents: 'read'
      id-token: 'write'
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Authenticate to Google Cloud
        uses: 'google-github-actions/auth@v2'
        with:
          workload_identity_provider: "projects/${{ env.GCP_PROJECT_NUMBER }}/locations/global/workloadIdentityPools/${{ env.WIF_POOL }}/providers/${{ env.WIF_PROVIDER }}"
          service_account: ${{ env.GCP_SERVICE_ACCOUNT }}

      - name: ğŸ³ Configure Docker for GCR
        run: gcloud auth configure-docker ${{ env.GCR_HOSTNAME }} --quiet

      - name: ğŸ—ï¸ Build Docker image
        run: |
          docker build \
            --file ${{ env.DOCKERFILE_PATH }} \
            --tag ${{ needs.setup.outputs.image-full }} \
            .
      
      - name: ğŸ§ª Test Docker image (Smoke Test)
        run: |
          echo "ğŸ§ª Iniciando teste de fumaÃ§a..."
          
          # Inicia o contÃªiner em background com variÃ¡veis de ambiente fictÃ­cias que o Strapi exige
          docker run -d --name strapi-test \
            -p 1337:1337 \
            -e NODE_ENV=development \
            -e DATABASE_CLIENT=sqlite \
            -e DATABASE_FILENAME=.tmp/test.db \
            -e JWT_SECRET=test-jwt-secret-dummy-value-for-testing \
            -e ADMIN_JWT_SECRET=test-admin-jwt-secret-dummy-value-for-testing \
            -e APP_KEYS='testkey1,testkey2,testkey3,testkey4' \
            -e API_TOKEN_SALT=test-api-token-salt \
            -e TRANSFER_TOKEN_SALT=test-transfer-token-salt \
            ${{ needs.setup.outputs.image-full }}

          echo "â³ Aguardando contÃªiner inicializar (atÃ© 60s)..."
          
          # Espera atÃ© que o Strapi responda no endpoint de health ou o tempo se esgote (60s)
          timeout 60s bash -c 'until curl -f http://localhost:1337/admin/health/strapi; do sleep 5; done'

          echo "âœ… Teste de fumaÃ§a concluÃ­do com sucesso. O contÃªiner iniciou corretamente."

      - name: ğŸ§¹ Clean up test container
        if: always() # Garante que este passo sempre rode, mesmo que o teste falhe
        run: |
          echo "ğŸ§¹ Limpando contÃªiner de teste..."
          docker logs strapi-test || true
          docker stop strapi-test || true
          docker rm strapi-test || true

  # Job para push da imagem
  push:
    name: ğŸ“¤ Push to Registry
    runs-on: ubuntu-latest
    needs: [setup, build]
    if: github.event_name != 'pull_request' && needs.setup.outputs.should-build == 'true'

    permissions:
      contents: 'read'
      id-token: 'write'
    
    steps:
      - name: ğŸ” Authenticate to Google Cloud
        uses: 'google-github-actions/auth@v2'
        with:
          workload_identity_provider: "projects/${{ env.GCP_PROJECT_NUMBER }}/locations/global/workloadIdentityPools/${{ env.WIF_POOL }}/providers/${{ env.WIF_PROVIDER }}"
          service_account: ${{ env.GCP_SERVICE_ACCOUNT }}

      - name: ğŸ³ Configure Docker for GCR
        run: gcloud auth configure-docker ${{ env.GCR_HOSTNAME }} --quiet

      - name: ğŸ—ï¸ Rebuild image for push cache
        # O build precisa ser refeito neste job para que o Docker tenha a imagem em seu contexto.
        # Isso Ã© rÃ¡pido pois o cache de layers do Docker geralmente Ã© utilizado.
        run: |
          docker build \
            --file ${{ env.DOCKERFILE_PATH }} \
            --tag ${{ needs.setup.outputs.image-full }} \
            .

      - name: ğŸ“¤ Push image to GCR
        run: |
          docker push ${{ needs.setup.outputs.image-full }}
          
          # Se for a branch principal, tambÃ©m envia com a tag 'latest'
          if [[ "${{ github.ref }}" == "refs/heads/main" ]] || [[ "${{ github.ref }}" == "refs/heads/master" ]]; then
            docker tag ${{ needs.setup.outputs.image-full }} ${{ env.GCR_HOSTNAME }}/${{ env.GCP_PROJECT_ID }}/${{ env.IMAGE_NAME }}:latest
            docker push ${{ env.GCR_HOSTNAME }}/${{ env.GCP_PROJECT_ID }}/${{ env.IMAGE_NAME }}:latest
          fi

  # Job para limpeza de imagens antigas
  cleanup:
    name: ğŸ§¹ Cleanup Old Images
    runs-on: ubuntu-latest
    needs: [setup, push]
    if: always() && needs.push.result == 'success'

    permissions:
      contents: 'read'
      id-token: 'write'
    
    steps:
      - name: ğŸ” Authenticate to Google Cloud
        uses: 'google-github-actions/auth@v2'
        with:
          workload_identity_provider: "projects/${{ env.GCP_PROJECT_NUMBER }}/locations/global/workloadIdentityPools/${{ env.WIF_POOL }}/providers/${{ env.WIF_PROVIDER }}"
          service_account: ${{ env.GCP_SERVICE_ACCOUNT }}

      - name: ğŸ§¹ Clean up old images
        run: |
          # MantÃ©m apenas as 10 imagens mais recentes e apaga as com mais de 30 dias
          gcloud artifacts docker images delete ${{ env.GCR_HOSTNAME }}/${{ env.GCP_PROJECT_ID }}/${{ env.IMAGE_NAME }} \
            --delete-tags \
            --keep-tags=10 \
            --filter="createTime<-P30D" \
            --quiet