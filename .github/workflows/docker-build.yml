# .github/workflows/docker-build.yml
# Workflow para build e push de imagem Docker para Google Container Registry
# Projeto: DevOps UNISATC A3 - Strapi Application

name: ğŸ³ Docker Build & Push

on:
  push:
    branches: [ master, main ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ master, main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      force_rebuild:
        description: 'Force rebuild even if no changes'
        type: boolean
        default: false

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GCR_HOSTNAME: gcr.io
  IMAGE_NAME: devops-unisatc-a3-strapi
  DOCKERFILE_PATH: ./Dockerfile

jobs:
  # Job para configurar variÃ¡veis de ambiente
  setup:
    name: ğŸ”§ Setup Environment
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.meta.outputs.image-tag }}
      image-full: ${{ steps.meta.outputs.image-full }}
      should-build: ${{ steps.changes.outputs.should-build }}
      environment: ${{ steps.meta.outputs.environment }}
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ğŸ·ï¸ Generate metadata
        id: meta
        run: |
          # Determina environment
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]] || [[ "${{ github.ref }}" == "refs/heads/master" ]]; then
            ENVIRONMENT="production"
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            ENVIRONMENT="production"
          else
            ENVIRONMENT="staging"
          fi
          
          # Gera tag da imagem
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            IMAGE_TAG=${GITHUB_REF#refs/tags/}
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]] || [[ "${{ github.ref }}" == "refs/heads/master" ]]; then
            IMAGE_TAG="latest"
          else
            IMAGE_TAG="${GITHUB_SHA::8}"
          fi
          
          # Adiciona sufixo do environment se nÃ£o for production
          if [[ "$ENVIRONMENT" != "production" ]]; then
            IMAGE_TAG="${IMAGE_TAG}-${ENVIRONMENT}"
          fi
          
          IMAGE_FULL="${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.IMAGE_NAME }}:${IMAGE_TAG}"
          
          echo "image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "image-full=${IMAGE_FULL}" >> $GITHUB_OUTPUT
          echo "environment=${ENVIRONMENT}" >> $GITHUB_OUTPUT
          
          echo "ğŸ·ï¸ Image tag: ${IMAGE_TAG}"
          echo "ğŸ³ Full image: ${IMAGE_FULL}"
          echo "ğŸŒ Environment: ${ENVIRONMENT}"

      - name: ğŸ” Check for changes
        id: changes
        run: |
          SHOULD_BUILD="true"
          
          # Se for workflow_dispatch com force_rebuild=false, verifica mudanÃ§as
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]] && [[ "${{ github.event.inputs.force_rebuild }}" == "false" ]]; then
            # Verifica se houve mudanÃ§as relevantes
            if git diff --quiet HEAD~1 HEAD -- . ':!.github' ':!docs' ':!*.md'; then
              echo "â„¹ï¸ Nenhuma mudanÃ§a relevante detectada"
              SHOULD_BUILD="false"
            fi
          fi
          
          echo "should-build=${SHOULD_BUILD}" >> $GITHUB_OUTPUT
          echo "ğŸ”¨ Should build: ${SHOULD_BUILD}"

  # Job para build e teste da imagem
  build:
    name: ğŸ—ï¸ Build Docker Image
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.should-build == 'true'
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: ğŸ› ï¸ Setup Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.PROJECT_ID }}

      - name: ğŸ³ Configure Docker for GCR
        run: |
          gcloud auth configure-docker ${{ env.GCR_HOSTNAME }}

      - name: ğŸ” Validate Dockerfile
        run: |
          echo "ğŸ” Validando Dockerfile..."
          
          # Verifica se Dockerfile existe
          if [[ ! -f "${{ env.DOCKERFILE_PATH }}" ]]; then
            echo "âŒ Dockerfile nÃ£o encontrado em ${{ env.DOCKERFILE_PATH }}"
            exit 1
          fi
          
          # Usa hadolint se disponÃ­vel
          if command -v hadolint &> /dev/null; then
            hadolint ${{ env.DOCKERFILE_PATH }}
          else
            echo "â„¹ï¸ hadolint nÃ£o disponÃ­vel, pulando lint do Dockerfile"
          fi
          
          echo "âœ… Dockerfile vÃ¡lido"

      - name: ğŸ—ï¸ Build Docker image
        run: |
          echo "ğŸ—ï¸ Building Docker image..."
          
          docker build \
            --file ${{ env.DOCKERFILE_PATH }} \
            --tag ${{ needs.setup.outputs.image-full }} \
            --tag ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.IMAGE_NAME }}:${{ github.sha }} \
            --label "org.opencontainers.image.title=${{ env.IMAGE_NAME }}" \
            --label "org.opencontainers.image.description=Strapi application for DevOps UNISATC A3" \
            --label "org.opencontainers.image.url=${{ github.server_url }}/${{ github.repository }}" \
            --label "org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}" \
            --label "org.opencontainers.image.version=${{ needs.setup.outputs.image-tag }}" \
            --label "org.opencontainers.image.created=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
            --label "org.opencontainers.image.revision=${{ github.sha }}" \
            --label "org.opencontainers.image.licenses=MIT" \
            --build-arg NODE_ENV=${{ needs.setup.outputs.environment }} \
            --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
            --build-arg VCS_REF=${{ github.sha }} \
            .
          
          echo "âœ… Image built successfully"

      - name: ğŸ§ª Test Docker image
        run: |
          echo "ğŸ§ª Testing Docker image..."
          
          # Testa se a imagem foi criada
          if ! docker image inspect ${{ needs.setup.outputs.image-full }} > /dev/null 2>&1; then
            echo "âŒ Image not found after build"
            exit 1
          fi
          
          # Testa se a imagem pode ser executada
          echo "ğŸš€ Testing container startup..."
          CONTAINER_ID=$(docker run -d \
            -e NODE_ENV=test \
            -e DATABASE_CLIENT=sqlite \
            -e DATABASE_FILENAME=.tmp/test.db \
            -e JWT_SECRET=test_jwt_secret \
            -e ADMIN_JWT_SECRET=test_admin_jwt_secret \
            -e APP_KEYS=test_key_1,test_key_2,test_key_3,test_key_4 \
            -e API_TOKEN_SALT=test_api_token_salt \
            -e TRANSFER_TOKEN_SALT=test_transfer_token_salt \
            -p 1337:1337 \
            ${{ needs.setup.outputs.image-full }})
          
          # Aguarda container inicializar
          echo "â³ Waiting for container to start..."
          sleep 30
          
          # Verifica se container estÃ¡ rodando
          if ! docker ps | grep -q $CONTAINER_ID; then
            echo "âŒ Container failed to start"
            docker logs $CONTAINER_ID
            exit 1
          fi
          
          # Verifica health endpoint
          echo "ğŸ” Testing health endpoint..."
          for i in {1..10}; do
            if curl -f http://localhost:1337/_health; then
              echo "âœ… Health check passed"
              break
            fi
            if [ $i -eq 10 ]; then
              echo "âŒ Health check failed after 10 attempts"
              docker logs $CONTAINER_ID
              exit 1
            fi
            sleep 5
          done
          
          # Limpa container de teste
          docker stop $CONTAINER_ID
          docker rm $CONTAINER_ID
          
          echo "âœ… Image testing completed successfully"

      - name: ğŸ”’ Security scan
        run: |
          echo "ğŸ”’ Scanning image for vulnerabilities..."
          
          # Instala Trivy se nÃ£o estiver disponÃ­vel
          if ! command -v trivy &> /dev/null; then
            sudo apt-get update
            sudo apt-get install wget apt-transport-https gnupg lsb-release
            wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
            echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
            sudo apt-get update
            sudo apt-get install trivy
          fi
          
          # Executa scan de vulnerabilidades
          trivy image \
            --exit-code 1 \
            --severity HIGH,CRITICAL \
            --format table \
            ${{ needs.setup.outputs.image-full }}
        continue-on-error: true

      - name: ğŸ“Š Generate image report
        run: |
          echo "ğŸ“Š Generating image report..."
          
          # InformaÃ§Ãµes da imagem
          IMAGE_SIZE=$(docker image inspect ${{ needs.setup.outputs.image-full }} --format='{{.Size}}' | numfmt --to=iec)
          IMAGE_LAYERS=$(docker image inspect ${{ needs.setup.outputs.image-full }} --format='{{len .RootFS.Layers}}')
          
          echo "## ğŸ³ Docker Image Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Image Name** | \`${{ needs.setup.outputs.image-full }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Tag** | \`${{ needs.setup.outputs.image-tag }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Size** | ${IMAGE_SIZE} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Layers** | ${IMAGE_LAYERS} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Environment** | ${{ needs.setup.outputs.environment }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Commit** | \`${{ github.sha }}\` |" >> $GITHUB_STEP_SUMMARY

  # Job para push da imagem
  push:
    name: ğŸ“¤ Push to Registry
    runs-on: ubuntu-latest
    needs: [setup, build]
    if: github.event_name != 'pull_request' && needs.setup.outputs.should-build == 'true'
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ” Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: ğŸ› ï¸ Setup Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.PROJECT_ID }}

      - name: ğŸ³ Configure Docker for GCR
        run: |
          gcloud auth configure-docker ${{ env.GCR_HOSTNAME }}

      - name: ğŸ—ï¸ Rebuild image for push
        run: |
          echo "ğŸ—ï¸ Rebuilding image for push..."
          
          docker build \
            --file ${{ env.DOCKERFILE_PATH }} \
            --tag ${{ needs.setup.outputs.image-full }} \
            --tag ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.IMAGE_NAME }}:${{ github.sha }} \
            --label "org.opencontainers.image.title=${{ env.IMAGE_NAME }}" \
            --label "org.opencontainers.image.description=Strapi application for DevOps UNISATC A3" \
            --label "org.opencontainers.image.url=${{ github.server_url }}/${{ github.repository }}" \
            --label "org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}" \
            --label "org.opencontainers.image.version=${{ needs.setup.outputs.image-tag }}" \
            --label "org.opencontainers.image.created=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
            --label "org.opencontainers.image.revision=${{ github.sha }}" \
            --label "org.opencontainers.image.licenses=MIT" \
            --build-arg NODE_ENV=${{ needs.setup.outputs.environment }} \
            --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
            --build-arg VCS_REF=${{ github.sha }} \
            .

      - name: ğŸ“¤ Push image to GCR
        run: |
          echo "ğŸ“¤ Pushing image to Google Container Registry..."
          
          # Push com tag especÃ­fica
          docker push ${{ needs.setup.outputs.image-full }}
          
          # Push com SHA do commit
          docker push ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          
          echo "âœ… Image pushed successfully to GCR"

      - name: ğŸ·ï¸ Tag additional versions
        if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
        run: |
          echo "ğŸ·ï¸ Tagging additional versions..."
          
          # Tag como 'latest' se for branch principal
          docker tag ${{ needs.setup.outputs.image-full }} ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.IMAGE_NAME }}:latest
          docker push ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.IMAGE_NAME }}:latest
          
          # Tag com timestamp
          TIMESTAMP=$(date -u +'%Y%m%d-%H%M%S')
          docker tag ${{ needs.setup.outputs.image-full }} ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.IMAGE_NAME }}:${TIMESTAMP}
          docker push ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.IMAGE_NAME }}:${TIMESTAMP}
          
          echo "âœ… Additional tags pushed"

      - name: ğŸ“‹ Generate push report
        run: |
          echo "ğŸ“‹ Generating push report..."
          
          # Lista imagens no registry
          echo "ğŸ“¦ Images in registry:" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          gcloud container images list-tags ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.IMAGE_NAME }} \
            --limit=10 \
            --sort-by=~timestamp \
            --format="table(digest.short,tags,timestamp)" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

  # Job para limpeza de imagens antigas
  cleanup:
    name: ğŸ§¹ Cleanup Old Images
    runs-on: ubuntu-latest
    needs: [setup, push]
    if: always() && needs.push.result == 'success'
    
    steps:
      - name: ğŸ” Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: ğŸ› ï¸ Setup Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.PROJECT_ID }}

      - name: ğŸ§¹ Clean up old images
        run: |
          echo "ğŸ§¹ Cleaning up old images..."
          
          # MantÃ©m apenas as 10 imagens mais recentes
          IMAGES_TO_DELETE=$(gcloud container images list-tags ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.IMAGE_NAME }} \
            --limit=999 \
            --sort-by=~timestamp \
            --format="get(digest)" \
            --filter="timestamp.datetime < '-P30D'")
          
          if [ -n "$IMAGES_TO_DELETE" ]; then
            echo "ğŸ—‘ï¸ Deleting old images..."
            echo "$IMAGES_TO_DELETE" | while read digest; do
              if [ -n "$digest" ]; then
                gcloud container images delete ${{ env.GCR_HOSTNAME }}/${{ env.PROJECT_ID }}/${{ env.IMAGE_NAME }}@${digest} \
                  --force-delete-tags \
                  --quiet
                echo "ğŸ—‘ï¸ Deleted: ${digest}"
              fi
            done
          else
            echo "â„¹ï¸ No old images to delete"
          fi

  # Job para notificaÃ§Ãµes
  notify:
    name: ğŸ“¬ Notifications
    runs-on: ubuntu-latest
    needs: [setup, build, push, cleanup]
    if: always()
    
    steps:
      - name: ğŸ“Š Generate final report
        run: |
          echo "ğŸ“Š Generating final report..."
          
          BUILD_STATUS="${{ needs.build.result }}"
          PUSH_STATUS="${{ needs.push.result }}"
          
          echo "## ğŸ³ Docker Build & Push Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Stage | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Build | $([ "$BUILD_STATUS" = "success" ] && echo "âœ… SUCCESS" || echo "âŒ FAILED") |" >> $GITHUB_STEP_SUMMARY
          echo "| Push | $([ "$PUSH_STATUS" = "success" ] && echo "âœ… SUCCESS" || echo "âŒ SKIPPED/FAILED") |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ needs.setup.outputs.should-build }}" = "true" ]; then
            echo "ğŸ¯ **Target**: ${{ needs.setup.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
            echo "ğŸ·ï¸ **Tag**: \`${{ needs.setup.outputs.image-tag }}\`" >> $GITHUB_STEP_SUMMARY
            echo "ğŸ“¦ **Image**: \`${{ needs.setup.outputs.image-full }}\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "â„¹ï¸ **Build skipped**: No relevant changes detected" >> $GITHUB_STEP_SUMMARY
          fi

      - name: ğŸ“¬ Send Slack notification (on failure)
        if: failure() && github.ref == 'refs/heads/main'
        run: |
          echo "ğŸ“¬ Would send Slack notification about Docker build failure"
          # Aqui vocÃª pode adicionar integraÃ§Ã£o com Slack se necessÃ¡rio
          # curl -X POST -H 'Content-type: application/json' \
          #   --data '{"text":"ğŸš¨ Docker build failed for DevOps UNISATC A3"}' \
          #   ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: âœ… Success notification
        if: needs.build.result == 'success' && needs.push.result == 'success'
        run: |
          echo "âœ… Docker image built and pushed successfully!"
          echo "ğŸ³ Image: ${{ needs.setup.outputs.image-full }}"
          echo "ğŸ¯ Environment: ${{ needs.setup.outputs.environment }}"

      - name: âŒ Failure notification
        if: failure()
        run: |
          echo "âŒ Docker build/push pipeline failed!"
          echo "ğŸ” Check the logs above for details"
          exit 1